Алгоритмы планирования пути: Алгоритмы на графах.


# Введение: виды алгоритмов маршрутизации
Алгоритмы планирования пути - нахождение коллизий перехода (пути) из некоторой начальной в некоторую конечноую
кофигурации в пространстве с препятсвиями.
Любой подход к решению этой задачи сводится к следующим шагам:

1. Определение пространства конфигураций (всех возможных состояний робота, например, положение на плоскости: (x, y, teta))
2. Декомпозиция (дискретизация) пространства
3. Поиск пути в дискретезированном пространстве

Типы декомпозиции пространства конфигураций:
1. Клеточная декомпозиция (cell decomposition) — пространство
разбиваетсā на клетки. Граф связаности строится на основе
смежности клеток.
2. Маршрутная декомпозиция (roadmap decomposition) —
представляет свободное пространство в виде связаных кривых
(маршрутов).
3. Потенциальное поле (potential field) — определāет
потенциалþное поле над пространством конфигураций с
минимумом в целевой точке и максимумами в препятсвиях.

Ко второму типу относятся такие методы, как:
- граф видимости (сложность построения О(n ** 2 * log(n))): в качестве узлов используются все вершины препятсвий, начальная
и конечная точки маршрута, две вершины соединяются ребрами, если одна вершина "видна" из другой и не пересекает препятсвий.
![img_1.png](img_1.png)
- диаграммы Вороного (наивный алгоритм О(n ** 4), лучший O(n * log(n))), где установка точек выбирается так, чтобы они 
находились на максимальном отдалении от препятсвий
![img_2.png](img_2.png)
- метод решетки состояний (наиболее часто применятся в беспилотных автомобилях), в котором пространство дискретезируется таким
образом, чтобы переходы между узлами были заранее кинематически достижимы (то есть с учетом киниматических ограничений определенного робота).
Явным достоинством такого разбиения является заведомо возоможная реализация движений и применения любых алгоритмов поиска в направленном графе.
![img_3.png](img_3.png)
- быстро исследующие случайные деревья: изначально в дереве существует только стартовый узел, затем создается новый случайный из свободного 
пространства и соединяется с ближайшим узлом дерева, при этом, если ребро проходит через препятсвие, то оставляют только максимальную часть ребра, 
непересекающую препятвие. С определенной периодичностью в качестве случайной точки берут целевую, если удается соеденить - то путь найден
![img_4.png](img_4.png) ![img_5.png](img_5.png)

При использовании потенциальных полей задается навигационная функция, указывающая направление к целевой точке из текущей конфигурации, такая что
препятвия отталкивают робота, а целевая точка - притягивает.

![img_6.png](img_6.png)



Согласно  [1] разделим методы планирования пути на следующие группы:
![img.png](img.png)

К метдам на основе интеллектуальных технологий отнесём муравьиный алгоритм, методы на ососнове нейронных сетей, а также реактивные методы.
При решении задачи оптимизационными методами учитываются различные ограничения (например, недопустимость высокого значения производной ускорения, от 
которой зависит укачивание в автомобиле), которые чаще всего задаются как штрафные функции, исходя из которых составляется интеграл, который необходимо
минимизировать. Следует отметить, что оптимальное планирование траектории — это задача другого
класса, нежели задача простого планирования. Решение первой — заметно более трудоемкое, чем решение второй. Классические методы оптимального управления основаны на
нетривиальных аналитических вычислениях. Поэтому подход, основанный на оптимальном управлении, эффективен для простых, в частности, линейных систем, а для сложных
нелинейных систем его реализовать труднее. 

По готовому графу или сетке существует достаточно много алгоритмов планирования пути. К самым простым можно отнести метод распространения
волонового фронта (алгоритм Ли), который является поиском в ширину по карте. Для планирования пути он подходит в редких ситуациях, однако он
нашел свое место в разводке печатных плат и поиск кратчайшего пути в лабиринтах. Наиболее известным является алгоритм Дейкстеры, который был 
сформулирован ещё в 1959 году, однако наибольшее распространение получила его версия, дополненная эвристикой - А*. Версии этого алгоритм до сих пор
используется в навигационном стеке ROS и самого популярного фреймворка для беспилотных автомобилей - autoware.




# Основная часть
 
## Поиск пути в статическом графе: алгоритмы
Рассмотрим три алгоритма поиска в статическом (немизмеющемся) ориентированном взвешаном графе(более общий случай).
Он храниться с помощью списка вершин, каждая из которых имеет
список ребер с указанием на соседней и значения веса. Стоит отметить, что это не единственный возможный вариант 
представления графа, конкретное исполнение зависит от решаемой задачи.
Граф реализуется с помощью ромбовидного наследования, однако это не является необходимостью, а лишь служит для 
инкапсуляции методов поиска пути.

## Алгоритм Дейкстеры
### Описание
Разобьем все вершины на два множества: уже обработанные и еще нет. 
Изначально все вершины, кроме стартовой, считаемнем необработанными, и расстояния до них примем за бесконечность (до
начальной вершины - 0).
На каждой итерации из множества необработанных вершин берется вершина с минимальным 
расстоянием и обрабатывается: происходит релаксация всех ребер, из нее исходящих, 
после чего вершина помещается во множество уже обработанных вершин.


Для алгоритма Дейкстеры существует ограничение на неотрицательные веса ребер.

### Пример использования
Посмотрим работу алгоритма на следующем гарфе:
![img_9.png](img_9.png)
Посмотрим на работу алгоритма при каждой итерации:
![img_8.png](img_8.png)
Осуществляется поиск из перового узла в девятый. При первой итерации мы отмечаем соседние со стартом ноды как 
пройденные и выбираем 4 ноду (с наименьшим весом) для новой итерации алгоритма. При следующей итерации мы сталкиваемся с 
большим весом до 5 ноды, поэтому следующей рассматирваются связи третей ноды. В случае, когда появляется путь с меньшим
весом до известной вершины (например, для 6 вершины путь через 2 оказался дешевле, хотя сначала был составлен маршрут через 3), 
то он пересчитывается.

### Асимптотика
реализация с помощю различных очередей с приоритетом(кучи фибоначи и двоичной кучи)...


## А* 
### Описание и вариации
А* является алгоритмом информированного поиска, то есть помимо графа мы знаем дополнительную информацию о целевой точке (эвристику), 
с помощью которой можно быстрее найти путь. Приоритет обхода определяется суммой стоимости пути из начальной вершины в данную и 
эвристической оценки. Если приравнять к нулю эвристическую функцию, то алгоритм превратится в описаный выше алгоритм Дейкстеры,
а если обнулить стоимостную составляющую, то получится алгоритм жадного поиска.


Существует очень много дополнений и развитий этого алгоритма: D*, Theta*, hybrid A*, lifelong planing A* и другие. Каждая
из них используется для решения различных задач, D* может учитывать динамическую, новую информацию, theta* может оптимизировать
найденные вершины, упрощая маршрут.

В качестве эвристик может быть выбрана любая оптимистичная (по ней путь до целевой вершины должен быть не меньше точной стоимости пути).
Из распространенных хотелось бы отеметить:
- Расстояние до цели напрямик;
- Расстояние с учётом кинематических ограничений, но без учёта препятствий;
- Расстояние с учётом препятствий, но без кинематических ограничений;
- Максимум допустимых эвристик есть допустимая эвристика.

К недостаткам соит отнести, что в пространствах малой размерности путь почти всегда не является кинематически выполнимым, а
также в пространствах большой размерности время работы драматически ухудшается.

### Пример использования
Подопотный граф:
![img_11.png](img_11.png)
В качестве эвристики выберем тридиционно L2 норму. 

Перед началом работы создаются два списка open (граница) – список
узлов, которые находятся в очереди на посещение и closed – список
посещённых узлов.
1. Заносят начальный узел в границу (список open)
2. Для него вычисляется сумма эвристики и стоимость из начала
3. Определяется узел с наименьшим значением суммы и назначается текущим
4. Проверяют, не является ли текущий узел целевым
5. Текущий узел убирают из границы и заносят его в посещённые узлы
   (список closed)
6. Для каждого из узлов в границе вычисляется сумма
7. Для текущего узла находят соседей и заносят их в границу (список open)
8. Повторяют пункты 3-8

Реализация:
```c++
bool AStarGraph::AStarSearch(Node &source, Node &target, bool show_log) {
    list_names::list<Node*> closed;
    priority_queue_names::PriorityQueue<Node*, double> opened;

    // source node
    source.distSource = 0;
    source.distTargetEstimate = source.distSource + source.get_dist(target);

    opened.push(&source, source.distTargetEstimate);


    while (!opened.is_empty())
    {
        // check element of opened with min target dist
        Node* current_node = opened.back()->value;
        if ( current_node->x_pos == target.x_pos and current_node->y_pos == target.y_pos )
            return true;
        closed.push(current_node);
        opened.pop_min();

        // check neighbours
        for (auto current_edge : current_node->edges)
        {
            auto neighbour_node = current_edge->target;

            if (closed.is_in_list(neighbour_node)) {
                continue;}

            auto tmp_distNeighbourSource = current_node->distSource + current_edge->weight;

            if (!opened.is_data_in_queue(neighbour_node, neighbour_node->distTargetEstimate
                or tmp_distNeighbourSource < neighbour_node->distSource)){
                neighbour_node->fromNode = current_node;
                neighbour_node->distSource = tmp_distNeighbourSource;
                neighbour_node->distTargetEstimate = neighbour_node->distSource + neighbour_node->get_dist(target);
            }

            if (!opened.is_data_in_queue(neighbour_node, neighbour_node->distTargetEstimate)){
                opened.push(neighbour_node, neighbour_node->distTargetEstimate);
            }

        }
    }
    return false;
}
```


### Асимптотика


## Волновой алгоритм
### Описание 
Как уже было упомянуто, данный алгоритм реализует поиск в ширину на карте из стартовой вершины.
В зависимости от задачи выбирается, какие клетки будут считаться соседними. На рисунке представлены окрестности Мура и фон Неймана 
соответсвенно.

![img_12.png](img_12.png) ![img_13.png](img_13.png)

### Пример использования
При хранении гарфа описаным выше способом составление регулярной сетки является сложной и неэффективной задачей, поэтому воспользуемся 
ещё одним способом хранения гарфа - ...


### Асимптотика




# Заключение и выводы

# Список литературы #
1. Методы планирования пути в среде с препятствиями (обзор). / Лю В. - МГТУ им. Баумана, Москва, Математика и математическое моделирование,
2018 г. - 44 страницы.


# Приложение

```c++
function test_env(args, **kwargs) { 
	if(Hello) { 
		say (world!);
		} 
	} 
```